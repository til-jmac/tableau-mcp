import { GraphQLResponse } from '../../sdks/tableau/apis/metadataApi.js';
import { MetadataResponse } from '../../sdks/tableau/apis/vizqlDataServiceApi.js';

type Field = Partial<{
  name: string;
  dataType: string | null;
  defaultAggregation: string | null;
  description: string | null;
  descriptionInherited: Array<{
    attribute: string;
    value: string | null;
  } | null> | null;
  dataCategory: string | null;
  role: string | null;
  defaultFormat: string | null;
  formula: string | null;
  isAutoGenerated: boolean | null;
  hasUserReference: boolean | null;
  binSize: number | null;
}>;

export type FieldsResult = {
  fields: Array<Field>;
};

export function simplifyReadMetadataResult(readMetadataResult: MetadataResponse): FieldsResult {
  const simplifiedResponse: FieldsResult = {
    fields: [],
  };

  if (!readMetadataResult.data) {
    return simplifiedResponse;
  }

  // This is a simplified response that attempts to reduce tokens by
  // only including essential fields and renaming properties.
  for (const field of readMetadataResult.data) {
    const toPush: Field = {
      name: field.fieldCaption,
      dataType: field.dataType,
    };

    if (field.defaultAggregation) {
      toPush.defaultAggregation = field.defaultAggregation;
    }

    simplifiedResponse.fields.push(toPush);
  }

  return simplifiedResponse;
}

export function combineFields(
  readMetadataResult: MetadataResponse,
  listFieldsResult: GraphQLResponse,
): FieldsResult {
  // Create a response object that combines field data from
  // readMetadata (VizQL Data Service API) and listFields (GraphQL Metadata API) results
  // to optimize for LLM accuracy and reduce tokens in response.
  const combinedFields: FieldsResult = {
    fields: [],
  };

  if (!readMetadataResult.data) {
    if (listFieldsResult.data.publishedDatasources[0]?.fields.length) {
      // fallback to returning listFields results if we don't have any fields from readMetadata.
      for (const field of listFieldsResult.data.publishedDatasources[0].fields) {
        const toPush: Field = { name: field.name };
        if (field.dataType) {
          toPush.dataType = field.dataType;
        }
        if (field.aggregation) {
          toPush.defaultAggregation = field.aggregation;
        }
        populateFieldWithAdditionalProperties(field, toPush);
        combinedFields.fields.push(toPush);
      }
    }

    return combinedFields;
  }

  // Only include fields from readMetadata results in our response object since only those can be used in queries.
  for (const field of readMetadataResult.data) {
    // only keeping essential field properties.
    const toPush: Field = {
      name: field.fieldCaption,
      dataType: field.dataType,
    };

    if (field.defaultAggregation) {
      toPush.defaultAggregation = field.defaultAggregation;
    }

    combinedFields.fields.push(toPush);
  }

  if (!listFieldsResult.data.publishedDatasources[0]?.fields.length) {
    return combinedFields;
  }

  // Of the fields in our response object, populate them with additional properties we get from listFields results.
  for (const field of combinedFields.fields) {
    const matchingListField = listFieldsResult.data.publishedDatasources[0].fields.find(
      (f) => f.name === field.name,
    );
    if (matchingListField) {
      populateFieldWithAdditionalProperties(matchingListField, field);
    }
  }

  return combinedFields;
}

function populateFieldWithAdditionalProperties(sourceField: Field, targetField: Field): void {
  if (sourceField.description) {
    targetField.description = sourceField.description;
  }
  if (sourceField.descriptionInherited?.length) {
    targetField.descriptionInherited = sourceField.descriptionInherited;
  }
  if (sourceField.dataCategory) {
    targetField.dataCategory = sourceField.dataCategory;
  }
  if (sourceField.role) {
    targetField.role = sourceField.role;
  }
  if (sourceField.defaultFormat) {
    targetField.defaultFormat = sourceField.defaultFormat;
  }
  if (sourceField.formula) {
    targetField.formula = sourceField.formula;
    // Possibly null or undefined, only populate if true or false.
    if (sourceField.isAutoGenerated != undefined) {
      targetField.isAutoGenerated = sourceField.isAutoGenerated;
    }
    // Possibly null or undefined, only populate if true or false.
    if (sourceField.hasUserReference != undefined) {
      targetField.hasUserReference = sourceField.hasUserReference;
    }
  }
  // Possibly null or undefined, only populate if defined.
  if (sourceField.binSize != undefined) {
    targetField.binSize = sourceField.binSize;
  }
}
